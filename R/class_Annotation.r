#' @include utils.r

NULL

#' Class representing annotation for expression data.
#'
#' @description
#' An R6 class to represent transcriptome annotation with protein mapping.
#' Specifically, it provides the following features:
#' - Transcriptome annotation:
#'   - Association of transcript IDs with gene IDs, RNA types, and species
#'   - Association of gene IDs with gene symbols, protein IDs (UniProt), etc.
#' @details
#' For more information on how to specify the arguments, please refer to the
#' vignette defining file formats.
#' @export
Annotation <- R6::R6Class( # nolint
  "Annotation",
  public <- list(
    #' @description
    #' Initialize a new `Annotation` object.
    #'
    #' This method initializes a new `Annotation` object.
    #' @param annotation Path to the annotation file in GFF format / or as
    #'  described in the vignette. It can be a vector of files.
    #' @param format_gff If `TRUE`, the annotation file is in GFF format.
    #' @param idmapping Path to the idmapping file, which allows the
    #' mapping of uniprot id to gene id. If not give, the idmapping file will be
    #' downloaded from uniprot using taxon ID from annotation file.
    #' @param annotation_dir Path to a directory containing annotation CSV files
    #'   (previously generated by `write_to_directory`). If provided, this
    #'   takes precedence over `annotation` and `idmapping`.
    #' @param log_level Logging level, e.g., "INFO", "WARN", "DEBUG".
    #' @param suffix_pattern The regex pattern used see clean_txid_versions
    #'   method.
    #' @return A new `Annotation` object.
    initialize = function(
      annotation = NULL,
      format_gff = TRUE,
      idmapping = NULL,
      annotation_dir = NULL,
      log_level = "WARN",
      suffix_pattern = "\\.\\d+$"
    ) {
      logging::basicConfig(log_level)

      if (!is.null(annotation_dir)) {
        logging::logdebug("Annotation$initialize: Initializing from directory %s", annotation_dir)
        private$initialize_from_directory(annotation_dir)
      } else if (!is.null(annotation)) {
        # Original initialization logic using annotation files
        if (format_gff) {
          logging::logdebug("Annotation$initialize: Parsing GFF annotation")
        # If the annotation file is in GFF format, parse it using the parse_gff
        # to_annotation function
        annotation <- data.table::rbindlist(
          lapply(annotation, parse_gff_to_annotation)
          )
        } else {
          # If the annotation file is not in GFF format, read it using
          # data.table::fread
          logging::logdebug("Annotation$initialize: Reading non-GFF annotation")
          annotation <- data.table::rbindlist(lapply(annotation, function(x) {
            data.table::fread(
              x, sep = " ",
              col.names = c(
                "txid", "gid", "type", "symbol", "tax_id", "tax_name"
              ),
              colTypes = c("c", "c", "c", "c", "c", "c")
            )
          }))
        }
        logging::logdebug("Annotation$initialize: Calling private$initialize_annotation")
        private$initialize_annotation(annotation, idmapping)
      } else {
        logging::logerror("Annotation$initialize: Either 'annotation' files or 'annotation_dir' must be provided.")
        stop("Initialization failed: No annotation source specified.")
      }
      self$clean_txid_versions(suffix_pattern)
      for (from_type in names(private$annotations)) {
        all_id <- unique(unlist(
          lapply(private$annotations[[from_type]], names)
        ))
        private$annotations[[from_type]][[from_type]] <- all_id
        names(private$annotations[[from_type]][[from_type]]) <- all_id
      }
    },

    #' @description
    #' generate a translate dictionary (named vector) from and id to another
    #' based on the annotation
    #' @param from the id type corresponding to the keys
    #' @param to the id type corresponding to the values
    #' @details
    #' Below is precised what is available and id type for value depending
    #' on id type for keys
    #' * Entrez Gene ID `gid` (Or equivalent on Ensembl,UCSC...)
    #'   * Gene symbol `symbol`
    #'   * Protein name `protein_names`
    #'   * Protein ID `uniprot`
    #'   * Taxon ID `tax_id`
    #'   * Taxon name `tax_name`
    #'   * Typed gene ID `tgid`
    #' * RefSeq transcript ID `txid` (Or equivalent on Ensembl,UCSC...)
    #'   * Entrez Gene ID `gid`
    #'   * rna type `type`
    #'   * Taxon ID `tax_id`
    #'   * Taxon name `tax_name`
    #'   * Typed gene ID `tgid`
    #' * Typed gene ID `tgid` i.e. gene id with type concatenated (sep is _)
    #' (one gene can have several type, some coding, some not coding)
    #'   * Gene symbol `symbol`
    #'   * Protein name `protein_names` (warning even if not coding type)
    #'   * Protein ID `uniprot` (warning even if not coding type)
    #'   * rna type `type`
    #'   * Taxon ID `tax_id`
    #'   * Taxon name `tax_name`
    #' * Uniprot protein ID `uniprot`
    #'   * Entrez Gene ID `gid`
    #'   * Protein name `protein_names`
    #'   * Gene symbol `symbol`
    #' * Gene symbol `symbol`
    #'   * Entrez Gene ID `gid`
    #'   * Protein ID `uniprot`
    #' @return a named vector that can translate from an id type to another
    generate_translate_dict = function(from, to) {
      if (! from %in% names(private$annotations)) {
        logging::logerror(
          "The `from` argument is not recognized in annotations"
        )
        logging::logerror(str(private$annotations))
        stop()
      }
      if (! to %in% names(private$annotations[[from]])) {
        logging::logerror(
          "The `to` argument is not recognized in annotations"
        )
        logging::logerror(str(private$annotations[[to]]))
        stop()
      }
      private$annotations[[from]][[to]]
    },

    #' Get the list of id type available for translate dicttionary as keys
    #'
    #' @return vecotr with potentioal key "from"
    get_from_ids = function() {
      names(private$annotations)
    },

    #' Get the list of id type available for translate dicttionary as values
    #' 
    #' @param from the key of the translate dictionary
    #' @return vecotr with potentioal key "to"
    get_to_ids = function(from) {
      if (! from %in% names(private$annotations)) {
        logging::logerror(
          "The `from` argument is not recognized in annotations"
        )
      }
      names(private$annotations[[from]])
    },

    #' @description
    #' Export annotation data to a data.frame for a given 'from' ID type.
    #'
    #' For a specified 'from' ID type, this method creates a data.frame
    #' where each row corresponds to a unique 'from' ID, and columns
    #' represent all associated 'to' ID types. Missing associations
    #' will be represented as NA.
    #'
    #' @param from The primary ID type (e.g., "gid", "txid") to use for rows.
    #' @return A data.frame with the 'from' ID type as the first column,
    #'   followed by columns for each derivable 'to' ID type. Returns an
    #'   empty data.frame if 'from' is invalid or no data can be constructed.
    export_to_df = function(from) {
      if (!from %in% self$get_from_ids()) {
        logging::logwarn(
          sprintf("Annotation$export_to_df: 'from' ID type '%s' is not valid. Valid types are: %s",
                  from, paste(self$get_from_ids(), collapse = ", "))
        )
        return(data.frame())
      }

      to_ids <- self$get_to_ids(from)

      all_unique_from_ids <- character(0)
      for (to_name in to_ids) {
        if (
          (!is.null(private$annotations[[from]][[to_name]])) &&
            (from != to_name)
        ) {
          all_unique_from_ids <- union(all_unique_from_ids, names(private$annotations[[from]][[to_name]]))
        }
      }

      all_unique_from_ids <- sort(unique(all_unique_from_ids))

      if (length(all_unique_from_ids) == 0) {
        # Construct an empty data frame with correct column names
        col_names <- c(from, to_ids)
        # Ensure no zero-length column names if to_ids is empty
        if (length(to_ids) == 0 && from == "") col_names <- character(0)
        else if (length(to_ids) == 0) col_names <- from

        empty_df <- data.frame(matrix(ncol = length(col_names), nrow = 0))
        if(length(col_names) > 0) colnames(empty_df) <- col_names
        return(empty_df)
      }

      data_list <- list()
      data_list[[from]] <- all_unique_from_ids

      if (length(to_ids) > 0) {
          for (to_id_type in to_ids) {
            mapping_vector <- private$annotations[[from]][[to_id_type]]
            # Ensure mapping_vector is not NULL before subsetting
            if (!is.null(mapping_vector)) {
                values <- mapping_vector[all_unique_from_ids]
                # If a to_id_type results in all NAs or is problematic, handle gracefully
                data_list[[to_id_type]] <- values
            } else {
                # If a specific to_id_type has no mapping vector, fill with NAs
                data_list[[to_id_type]] <- rep(NA, length(all_unique_from_ids))
            }
          }
      }
      
      df <- as.data.frame(data_list, stringsAsFactors = FALSE)

      if (ncol(df) > 0 && names(df)[1] != from) {
        names(df)[1] <- from
      }

      return(df)
    },

    #' @description
    #' Write all annotation data frames to a specified directory.
    #'
    #' This method iterates through all available 'from' ID types,
    #' generates a data.frame for each using `self$export_to_df()`,
    #' and writes each data.frame to a CSV file named after the
    #' 'from' ID type (e.g., "gid.csv") in the specified directory.
    #'
    #' @param directory_path The path to the directory where CSV files
    #'   will be written. The directory will be created if it does not exist.
    #' @return Invisibly returns TRUE if successful, or FALSE/throws error on failure.
    #'   Logs information about files written or warnings for types with no data.
    write_to_directory = function(directory_path) {
      if (missing(directory_path) || !is.character(directory_path) || length(directory_path) != 1 || nchar(directory_path) == 0) {
        logging::logerror("Annotation$write_to_directory: 'directory_path' must be a non-empty string.")
        return(invisible(FALSE))
      }

      if (!dir.exists(directory_path)) {
        logging::loginfo(sprintf("Annotation$write_to_directory: Creating directory: %s", directory_path))
        dir.create(directory_path, showWarnings = FALSE, recursive = TRUE)
      }

      all_from_types <- self$get_from_ids()
      if (length(all_from_types) == 0) {
        logging::logwarn("Annotation$write_to_directory: No 'from' ID types available to export.")
        return(invisible(TRUE)) # No error, but nothing to do
      }

      success_all <- TRUE
      for (current_from_type in all_from_types) {
        df_to_write <- self$export_to_df(current_from_type)

        if (!is.null(df_to_write) && inherits(df_to_write, "data.frame") && nrow(df_to_write) > 0) {
          file_name <- paste0(current_from_type, ".csv")
          output_path <- file.path(directory_path, file_name)
          data.table::fwrite(df_to_write, output_path, row.names = FALSE, na = "NA")
        } else {
          logging::logwarn(
            sprintf("Annotation$write_to_directory: No data to write for 'from' ID type '%s'. Skipping.", current_from_type)
          )
        }
      }
      return(invisible(success_all))
    },

    #' @description
    #' Clean version suffixes from transcript IDs within the internal annotation
    #' structures.
    #'
    #' This method iterates through the `private$annotations` object.
    #' If a `from_key` (names of a mapping) is "txid", it cleans these names.
    #' If a `to_key` (values of a mapping) is "txid", it cleans these values.
    #' It uses the `remove_id_version_suffix` utility function.
    #'
    #' @param suffix_pattern (character) The regex pattern for the version
    #'   suffix. Default is `"\\.\\d+$"`. If `NULL`, `FALSE`, or an empty
    #'   string, no cleaning is performed.
    clean_txid_versions = function(suffix_pattern = "\\.\\d+$") {

      for (from_key in names(private$annotations)) {
        for (to_key in names(private$annotations[[from_key]])) {
          if (from_key == "txid") {
            names(private$annotations[[from_key]][[to_key]]) <-
              remove_id_version_suffix(
                names(private$annotations[[from_key]][[to_key]]),
                suffix_pattern
              )
          }
          if (to_key == "txid") {
            private$annotations[[from_key]][[to_key]] <-
              remove_id_version_suffix(
                private$annotations[[from_key]][[to_key]],
                suffix_pattern
              )
          }
        }
      }
    }

  ),
  private <- list(
    # Annotation dict
    annotations = NULL,

    # initialize annotation
    initialize_annotation = function(annotation, idmapping) {
      # Parse annotation
      annotations <- list(
        "gid" = list(),
        "txid" = list(),
        "tgid" = list(),
        "uniprot" = list(),
        "symbol" = list()
      )

      if (is.null(idmapping)) {
        idmapping <- data.table::rbindlist(lapply(
          unique(annotation$tax_id),
          fetch_id_mapping
        ))
      }

      dest_vector <- c("type", "tax_id", "tax_name", "gid")

      for (dest in dest_vector) {
        annotations[["txid"]][[dest]] <- annotation[[dest]]
        names(annotations[["txid"]][[dest]]) <- annotation$txid
      }

      annotation_gene <- unique(annotation[, !c("txid")])
      dest_vector <- c("symbol", "tax_id", "tax_name")
      for (dest in dest_vector) {
        annotations[["gid"]][[dest]] <- annotation_gene[[dest]]
        names(annotations[["gid"]][[dest]]) <- annotation_gene$gid
      }

      logging::logdebug("Annot: Run create_id_mappings function")
      annotation_dt <- unique(annotation[, .(gid, symbol)])

      id_mappings <- create_uniprot_gene_id_mappings(idmapping, annotation_dt)

      annotations[["uniprot"]][["gid"]] <- id_mappings[["uniprot2gid"]]
      annotations[["uniprot"]][["protein_names"]] <-
        id_mappings[["uniprot2name"]]
      annotations[["gid"]][["uniprot"]] <- id_mappings[["gid2uniprot"]]

      annotations[["gid"]][["protein_names"]] <-
        annotations[["uniprot"]][["protein_names"]][
          annotations[["gid"]][["uniprot"]]
        ]

      names(annotations[["gid"]][["protein_names"]]) <-
        names(annotations[["gid"]][["uniprot"]])

      annotations[["uniprot"]][["symbol"]] <-
        annotations[["gid"]][["symbol"]][annotations[["uniprot"]][["gid"]]]

      names(annotations[["uniprot"]][["symbol"]]) <-
        names(annotations[["uniprot"]][["gid"]])

      df <- data.frame(
        txid = names(annotations[["txid"]][["gid"]]),
        gid = annotations[["txid"]][["gid"]],
        type = annotations[["txid"]][["type"]]
      )

      df$tgid <- stringr::str_c(df$gid, df$type, sep = "_")

      annotations[["txid"]][["tgid"]] <- df$tgid
      names(annotations[["txid"]][["tgid"]]) <- df$txid

      df_gid_tgid <- unique(df[, c("gid", "tgid")])
      df_type_tgid <- unique(df[, c("type", "tgid")])

      annotations[["tgid"]] <- list()

      annotations[["tgid"]][["gid"]] <- df_gid_tgid[["gid"]]
      names(annotations[["tgid"]][["gid"]]) <- df_gid_tgid[["tgid"]]

      annotations[["tgid"]][["type"]] <- df_type_tgid[["type"]]
      names(annotations[["tgid"]][["type"]]) <- df_type_tgid[["tgid"]]

      dest_vector <-
        c("protein_names", "uniprot", "symbol", "tax_id", "tax_name")
      for (dest in dest_vector) {
        annotations[["tgid"]][[dest]] <-
          annotations[["gid"]][[dest]][df_gid_tgid[["gid"]]]
        names(annotations[["tgid"]][[dest]]) <- df_gid_tgid[["tgid"]]
      }

      # Add symbol mappings
      logging::logdebug("Annot: Creating symbol mappings")
      # Use the annotation_dt created earlier which has unique gid-symbol pairs
      symbol_map_df <- data.table::copy(annotation_dt) # Contains gid, symbol
      # Add uniprot using the existing gid -> uniprot mapping
      symbol_map_df[, uniprot := annotations[["gid"]][["uniprot"]][gid]]

      # Create symbol -> gid mapping (keep only non-duplicated symbols)
      symbol_gid_df <-
        symbol_map_df[
          !is.na(symbol) & symbol != "" & !duplicated(symbol), .(symbol, gid)
        ]
      symbol_gid_vec <- symbol_gid_df$gid
      names(symbol_gid_vec) <- symbol_gid_df$symbol
      annotations[["symbol"]][["gid"]] <- symbol_gid_vec

      # Create symbol -> uniprot mapping (keep only non-duplicated symbols)
      symbol_uniprot_df <-
        symbol_map_df[
          !is.na(symbol) & symbol != "" & !is.na(uniprot) &
          !duplicated(symbol), .(symbol, uniprot)
        ]
      symbol_uniprot_vec <- symbol_uniprot_df$uniprot
      names(symbol_uniprot_vec) <- symbol_uniprot_df$symbol
      annotations[["symbol"]][["uniprot"]] <- symbol_uniprot_vec

      private$annotations <- annotations

    },

    # Initialize from a directory containing pre-generated CSV files
    initialize_from_directory = function(directory_path) {
      expected_from_types <- c("gid", "txid", "tgid", "uniprot", "symbol")

      private$annotations <- stats::setNames(
        lapply(expected_from_types, function(x) list()),
        expected_from_types
      )

      for (from_type in expected_from_types) {
        file_path <- file.path(directory_path, paste0(from_type, ".csv"))

        if (!file.exists(file_path)) {
          logging::logerror(
            "Annotation$private$initialize_from_directory:",
            " File not found for type '%s': %s. Skipping.",
            from_type,
            file_path
          )
        }

        tryCatch({
          df <- data.table::fread(
            file_path,
            na.strings = "NA",
            stringsAsFactors = FALSE,
            data.table = FALSE
          )

          if (names(df)[1] != from_type) {
            logging::logerror(
              "Annotation$private$initialize_from_directory:",
              "First column of %s is '%s', expected '%s'. Skipping file.",
              file_path,
              names(df)[1],
              from_type
            )
            next
          }

          # Get the 'from' IDs (keys)
          from_ids <- df[[from_type]]

          # Iterate through the remaining columns ('to' types)
          to_types <- names(df)[-1]
          for (to_type in to_types) {
            to_values <- df[[to_type]]
            valid_indices <- !is.na(to_values)
            mapping_vector <- to_values[valid_indices]
            names(mapping_vector) <- from_ids[valid_indices]
            private$annotations[[from_type]][[to_type]] <- mapping_vector
          }
        }, error = function(e) {
          logging::logerror(
            "Annotation$private$initialize_from_directory:",
            " Error reading or processing file %s for type '%s'. Error: %s",
            file_path, from_type, e$message
          )
        })
      }
    }
  )
)

#' utils function for this class only
#' scores min given for unique first and then for dups before merging
#' switch to data.table
#' @param idmapping data.table with id mappings from uniprot KB
#' @param annotation data.table with annotation from gff files
#' @param reviewed_min_scores vector of two integers with min scores for
#' reviewed entries, first for unique and then for dups
#' @param unreviewed_min_scores vector of two integers with min scores for 
#' unreviewed entries, first for unique and then for dups
create_uniprot_gene_id_mappings <- function(
  idmapping,
  annotation,
  unique_reviewed_min_score = 1L,
  dups_reviewed_min_score = 4L,
  unique_unreviewed_min_score = 2L,
  dups_unreviewed_min_score = 5L
  ) {

  if (ncol(idmapping) == 6) {
    cnames <- c("uniprot", "status", "names", "symbol", "gid", "score")
  }else if (ncol(idmapping) == 5) {
    cnames <- c("uniprot", "status", "names", "gid", "score")
  }else {
    # If the idmapping data.table has a different number of columns, stop the execution
    stop("Uniprot mapping file not recognized")
  }

  data.table::setnames(idmapping, cnames)
  status_levels <- c("unreviewed", "reviewed")
  idmapping[, status := factor(status, levels = status_levels)]

  if (!is.numeric(idmapping$score)) {
    # Convert the score column to integer for old uniprotKB format
    idmapping[, score := as.integer(gsub(" out of 5", "", score))]
  }

  # NB: We do not consider protein spanning different genes that may be
  # fusion protein or readthrough transcripts
  idmapping <- idmapping[stringr::str_count(idmapping$gid, ";") == 1, ]
  idmapping[, gid := stringr::str_replace(gid, stringr::fixed(";"), "")]

  uniprot2gid <- idmapping$gid
  names(uniprot2gid) <- idmapping$uniprot
  uniprot2name <- idmapping$names
  names(uniprot2name) <- idmapping$uniprot

  is_dups <- duplicated(idmapping$gid)
  unique_idmapping <- idmapping[
    (!is_dups) & (
     ((status == "reviewed") & (score >= unique_reviewed_min_score)) |
      ((status == "unreviewed") & (score >= unique_unreviewed_min_score))
    )
    , ]
  dups_idmapping <- idmapping[
    (is_dups) & (
     ((status == "reviewed") & (score >= dups_reviewed_min_score)) |
      ((status == "unreviewed") & (score >= dups_unreviewed_min_score))
    )
    , ]

  is_still_dups <- duplicated(dups_idmapping$gid)
  unique_idmapping <- data.table::rbindlist(
    list(unique_idmapping, dups_idmapping[ !is_still_dups,])
  )
  dups_idmapping <- dups_idmapping[is_still_dups, ]
  data.table::setorder(dups_idmapping, -status, -score)

  dups_idmapping <- dups_idmapping[, .SD[1], by = gid]
  data.table::setcolorder(dups_idmapping, names(unique_idmapping))
  final_idmapping <- data.table::rbindlist(
    list(unique_idmapping, dups_idmapping)
  )

  final_idmapping[, score:= NULL] # nolint object_usage_linter
  final_idmapping[, status:= NULL] # nolint object_usage_linter

  gid2uniprot <- final_idmapping$uniprot
  names(gid2uniprot) <- final_idmapping$gid

  return(list(
    uniprot2gid = uniprot2gid,
    gid2uniprot = gid2uniprot,
    uniprot2name = uniprot2name
  ))
}
