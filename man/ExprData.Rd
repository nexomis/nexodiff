% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/class_ExprData.r
\name{ExprData}
\alias{ExprData}
\title{Show raw count summary per tax_id, tax_name and rna type for
selected expressed tags}
\description{
This class represents a RNA sequencing dataset containing the
following information:
\itemize{
\item expression values (raw count) of expressed tags (genes or transcripts) for
all samples.
\item effective lengths of expressed tags (genes or transcripts) for all samples.
\item normalization factors for expressed tags (genes or transcripts) for all
samples.
\item design and annotation information; see \link{PairwiseDesignWithAnnotation}
for details.
}

By convention, the dataset is represented as a matrix:
\itemize{
\item A column represents the expression values for one sample.
\item A row represents the expression values for one expression tag.
Column names are the sample names, and row names are the expression tag
names.
}
}
\details{
An R6 class representing an RNA-Seq expression dataset.
}
\examples{

## ------------------------------------------------
## Method `ExprData$show_etags_summary`
## ------------------------------------------------

show_etags_summary("raw")
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-ExprData-show_etags_summary}{\code{ExprData$show_etags_summary()}}
\item \href{#method-ExprData-filter_and_set_selected_ids}{\code{ExprData$filter_and_set_selected_ids()}}
\item \href{#method-ExprData-compute_and_set_inter_norm_fact}{\code{ExprData$compute_and_set_inter_norm_fact()}}
\item \href{#method-ExprData-compute_and_set_intra_norm_fact}{\code{ExprData$compute_and_set_intra_norm_fact()}}
\item \href{#method-ExprData-reset}{\code{ExprData$reset()}}
\item \href{#method-ExprData-get_raw}{\code{ExprData$get_raw()}}
\item \href{#method-ExprData-filter_and_get_raw}{\code{ExprData$filter_and_get_raw()}}
\item \href{#method-ExprData-get_len}{\code{ExprData$get_len()}}
\item \href{#method-ExprData-filter_and_get_len}{\code{ExprData$filter_and_get_len()}}
\item \href{#method-ExprData-compute_norm_fact}{\code{ExprData$compute_norm_fact()}}
\item \href{#method-ExprData-get_intra_norm_fact_method}{\code{ExprData$get_intra_norm_fact_method()}}
\item \href{#method-ExprData-get_inter_norm_fact_opts}{\code{ExprData$get_inter_norm_fact_opts()}}
\item \href{#method-ExprData-compute_norm}{\code{ExprData$compute_norm()}}
\item \href{#method-ExprData-is_with_fixed_length}{\code{ExprData$is_with_fixed_length()}}
\item \href{#method-ExprData-get_main_etag}{\code{ExprData$get_main_etag()}}
\item \href{#method-ExprData-is_at_gene_level}{\code{ExprData$is_at_gene_level()}}
\item \href{#method-ExprData-get_design}{\code{ExprData$get_design()}}
\item \href{#method-ExprData-sum_per_type_per_sample}{\code{ExprData$sum_per_type_per_sample()}}
\item \href{#method-ExprData-plot_sum_per_type_per_sample}{\code{ExprData$plot_sum_per_type_per_sample()}}
\item \href{#method-ExprData-plot_dist_per_sample}{\code{ExprData$plot_dist_per_sample()}}
\item \href{#method-ExprData-plot_complex}{\code{ExprData$plot_complex()}}
\item \href{#method-ExprData-plot_prcomp}{\code{ExprData$plot_prcomp()}}
\item \href{#method-ExprData-plot_corr}{\code{ExprData$plot_corr()}}
\item \href{#method-ExprData-extract_pairwise_data_with_design}{\code{ExprData$extract_pairwise_data_with_design()}}
\item \href{#method-ExprData-clone}{\code{ExprData$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-show_etags_summary"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-show_etags_summary}{}}}
\subsection{Method \code{show_etags_summary()}}{
This function computes a raw count summary per tax_id, tax_name and rna
type for selected expressed tags, and returns a list of count tables per
feature.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$show_etags_summary(type = "etags", in_batch = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{type}}{A string specifying the type of summary to compute. Possible
values are:
\itemize{
\item "etags" for the number of expression tags
\item "raw" for the sum of raw reads counts per samples
\item "norm" for the sum of normalized reads counts per samples.
}}

\item{\code{in_batch}}{(optional) A character vector specifying the batch(es) to
include.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of count tables per feature
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{show_etags_summary("raw")
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-filter_and_set_selected_ids"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-filter_and_set_selected_ids}{}}}
\subsection{Method \code{filter_and_set_selected_ids()}}{
Select expressed tags based on filtering on taxon or rna type.
The results will be an intersect with the previous selection.
You can reset the object if it's not desired.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$filter_and_set_selected_ids(
  values,
  filtered_var = "type",
  filter_type = "keep"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{values}}{A list of values used for filtering.}

\item{\code{filtered_var}}{The variable being filtered. Possible values are
\itemize{
\item "tax_id" for filtering based on taxon id
\item "tax_name" for filtering based on taxon name
\item "type" for filtering based on rna type (default)
}}

\item{\code{filter_type}}{The filtering method. Possible values are:
\itemize{
\item "keep" to keep only an expression tag if its value for the variable
designated with \code{filtered_var} is in \code{values}
\item "excl" to keep only an expression tag if its value for the variable
designated with \code{filtered_var} is not in \code{values}.
}}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-compute_and_set_inter_norm_fact"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-compute_and_set_inter_norm_fact}{}}}
\subsection{Method \code{compute_and_set_inter_norm_fact()}}{
Compute and set inter normalization factors with extensible
parametrization. Please be aware that this function is designed to handle
various normalization methods, including median and TMM. However, at the
time of implementation, only the median method has been thoroughly
tested. Other methods such as TMM might not produce accurate results and
should be used with caution.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$compute_and_set_inter_norm_fact(
  method = "median",
  norm_scale = "group",
  norm_by = "sample",
  norm_ref = "all",
  norm_ref_mean = "mod.geometric",
  m_trim_prop = 0.3,
  m_trim_mean = "mod.geometric",
  a_trim_value = 0.5,
  a_trim_norm = FALSE,
  a_trim_mean = "mod.geometric",
  replace_zero_by = 0,
  ncpus = 1
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{method}}{Normalization method to use:
\itemize{
\item "none" apply no normalization
\item "median" apply median ratio normalization
\item "tmm" apply trimmed mean of median normalization
TODO: add litterature reference for each
}}

\item{\code{norm_scale}}{Scale to apply the normalization:
\itemize{
\item "design" for all samples in one go
\item "batch" for applying norm_factors per batch
\item "group" for applying norm factors per batch per group.
}}

\item{\code{norm_by}}{Where to apply the normalization factor:
\itemize{
\item "samples" for the sample level
\item "group" for the group level (not implemented).
The normalized can be computed for each sample or can be computed based
on the mean expression within a group.
}}

\item{\code{norm_ref}}{Sample(s) to use as reference for normalization:
\itemize{
\item "all" for all samples
\item "ctrl" for control samples (not tested and not compatible with scale
design)
\item character vector with sample names (not tested)
\item integer vector with sample rank in expression matrix (not tested).
}}

\item{\code{norm_ref_mean}}{Method for the mean of gene expression between
samples of the reference. Possible options are given for \code{m_trim_mean}.}

\item{\code{m_trim_prop}}{Proportion of expression ratio (M-value) to trim at
both tails (only for TMM).}

\item{\code{m_trim_mean}}{Method for the mean of gene expression ratios in the
TMM method to compute the normalization factor. Possible options are:
\itemize{
\item "median"
\item "geometric"
\item "nz.geometric" geometric without zero
\item "mod.geometric" modified geometric with epsilon = 1e-05
(see https://arxiv.org/abs/1806.06403)
\item "arithmetic"
}}

\item{\code{a_trim_value}}{Threshold value to trim genes from the calculation of
the normalization factors based on mean gene expression (A-value).}

\item{\code{a_trim_norm}}{Whether to use (intra) normalized value to trim based
on mean gene expression (only FALSE tested).}

\item{\code{a_trim_mean}}{Method for the mean of gene expression between all
samples. Possible options are given for \code{m_trim_mean}.}

\item{\code{replace_zero_by}}{Replace all zero raw count by the given value.}

\item{\code{ncpus}}{Number of cpus to use for computation (default = 1)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-compute_and_set_intra_norm_fact"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-compute_and_set_intra_norm_fact}{}}}
\subsection{Method \code{compute_and_set_intra_norm_fact()}}{
Set intra normalization factors.
This function replaces any NaN values in the intra normalization factors
with 1. NaN values may occur when the denominator in the calculations is
0. Replacing NaN values with 1 ensures that the normalization factors do
not have missing or undefined values, which can cause issues in further
analyses.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$compute_and_set_intra_norm_fact(method)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{method}}{Normalization method:
\itemize{
\item "none" for no normalization
\item "fpm" for Fragment per million mapped
\item "fpk" for Fragment per kilobase of transcript
\item "tpm" for Transcript per million
\item "fpkm" for Fragment per kilobase of transcript per million mapped
}}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-reset"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-reset}{}}}
\subsection{Method \code{reset()}}{
Reset object, this affects:
\itemize{
\item expression tags selection (as initially)
\item samples selection (as initially)
\item normalization (No norm)
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$reset()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
interger matrix with raw counts for expressed tags
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-get_raw"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-get_raw}{}}}
\subsection{Method \code{get_raw()}}{
Get raw count matrix
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$get_raw()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
interger matrix with raw counts for expressed tags
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-filter_and_get_raw"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-filter_and_get_raw}{}}}
\subsection{Method \code{filter_and_get_raw()}}{
Filter and get raw count matrix
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$filter_and_get_raw(in_batch = NULL, in_group = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{in_batch}}{(optional) A character vector specifying the batch(es) to
include.}

\item{\code{in_group}}{(optional) A character vector specifying the group(s) to
include.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
interger matrix with raw counts for expressed tags
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-get_len"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-get_len}{}}}
\subsection{Method \code{get_len()}}{
Get effective length matrix
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$get_len()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
numeric matrix with effective length  for expressed tags
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-filter_and_get_len"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-filter_and_get_len}{}}}
\subsection{Method \code{filter_and_get_len()}}{
filter and get effective length matrix
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$filter_and_get_len(in_batch = NULL, in_group = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{in_batch}}{(optional) A character vector specifying the batch(es) to
include.}

\item{\code{in_group}}{(optional) A character vector specifying the group(s) to
include.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
numeric matrix with effective length  for expressed tags
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-compute_norm_fact"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-compute_norm_fact}{}}}
\subsection{Method \code{compute_norm_fact()}}{
Get normalization factors matrix
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$compute_norm_fact(
  in_batch = NULL,
  in_group = NULL,
  inter_norm = FALSE,
  intra_norm = TRUE,
  include_ctrl = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{in_batch}}{(optional) A character vector specifying the batch(es) to
include.}

\item{\code{in_group}}{(optional) A character vector specifying the group(s) to
include.}

\item{\code{inter_norm}}{A boolean indicating whether to apply inter-sample
normalization.}

\item{\code{intra_norm}}{A boolean indicating whether to apply intra-sample
normalization.}

\item{\code{include_ctrl}}{A boolean indicating whether to include the control
group. This argument is only valid when specifying only one argument for
'in_group' and 'in_batch'.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Numeric matrix with normalization factors for expressed tags
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-get_intra_norm_fact_method"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-get_intra_norm_fact_method}{}}}
\subsection{Method \code{get_intra_norm_fact_method()}}{
Get intra normalization method
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$get_intra_norm_fact_method()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
method name
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-get_inter_norm_fact_opts"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-get_inter_norm_fact_opts}{}}}
\subsection{Method \code{get_inter_norm_fact_opts()}}{
Get inter normalization methods
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$get_inter_norm_fact_opts()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
lists with all normalizations options
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-compute_norm"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-compute_norm}{}}}
\subsection{Method \code{compute_norm()}}{
Compute the normalized expression data from raw and norm matrices.IMPORTANT: Default is no normalization. Please use the function belowbeforehand.
\itemize{
\item "compute_and_set_intra_norm_fact"
\item "compute_and_set_inter_norm_fact"
Note that intra normalization is always applied, however inter norm is
optional. Depending on the \code{norm_scale} used for inter normalization,
the \code{in_batch} argument might be mandatory.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$compute_norm(
  in_batch = NULL,
  in_group = NULL,
  inter_norm = FALSE,
  include_ctrl = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{in_batch}}{(optional) A character vector specifying the batch(es) to
include.}

\item{\code{in_group}}{(optional) A character vector specifying the group(s) to
include.}

\item{\code{inter_norm}}{A boolean indicating whether to apply inter-sample
normalization.}

\item{\code{include_ctrl}}{A boolean indicating whether to include the control
group. This argument is only valid when specifying only one argument for
'in_group' and 'in_batch'.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
numeric matrix with norm counts for expressed tags
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-is_with_fixed_length"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-is_with_fixed_length}{}}}
\subsection{Method \code{is_with_fixed_length()}}{
Are the expression tags lengths fixed ?
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$is_with_fixed_length()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
numeric matrix with raw counts for expressed tags
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-get_main_etag"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-get_main_etag}{}}}
\subsection{Method \code{get_main_etag()}}{
Get the main expression tag id. The tag id corresponds to the unique id
linked with a expression point. It can be tx_id (for transcript id) or
"tgid" for "typed gene id". Why typed gene ID ? because some genes have
transcripts from different types. As it would not be biologically
relevant to aggregate different typse during the sum, a new id is create
that is gene and type specific.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$get_main_etag()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
chararacter representing the main espression tag id
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-is_at_gene_level"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-is_at_gene_level}{}}}
\subsection{Method \code{is_at_gene_level()}}{
Whether the expression data is at gene level or not.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$is_at_gene_level()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
T or F
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-get_design"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-get_design}{}}}
\subsection{Method \code{get_design()}}{
Extract the PairwiseDeisgnWithAnnotation instance that were used to
build the expression data object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$get_design()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
\code{PairwiseDeisgnWithAnnotation} object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-sum_per_type_per_sample"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-sum_per_type_per_sample}{}}}
\subsection{Method \code{sum_per_type_per_sample()}}{
Get sum of count or normalized value per rna type
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$sum_per_type_per_sample(intra_norm = FALSE, log2_expr = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{intra_norm}}{A boolean indicating whether to apply intra-sample
normalization.}

\item{\code{log2_expr}}{A boolean indicating whether to use the log2(x+2)
transformation for expression data.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
data frame with counts with colums
\itemize{
\item type: RNA type
\item sample: sample name
\item total: Sum of count or normalized value
}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-plot_sum_per_type_per_sample"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-plot_sum_per_type_per_sample}{}}}
\subsection{Method \code{plot_sum_per_type_per_sample()}}{
plot sum of count or intra-normalized values per rna type (Inter norm is
not available for this)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$plot_sum_per_type_per_sample(
  intra_norm = FALSE,
  exclude_type = c(),
  same_scale = TRUE,
  horizonal_bar = TRUE,
  log2_expr = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{intra_norm}}{A boolean indicating whether to apply intra-sample
normalization.}

\item{\code{exclude_type}}{character vector with the rne type to exclude from
the graph}

\item{\code{same_scale}}{whether to represent the scale with the same}

\item{\code{horizonal_bar}}{whether the bar in the plot are horizontal rather
than vertical}

\item{\code{log2_expr}}{A boolean indicating whether to use the log2(x+2)
transformation for expression data.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
ggplot2 graph
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-plot_dist_per_sample"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-plot_dist_per_sample}{}}}
\subsection{Method \code{plot_dist_per_sample()}}{
Plot the distribution of count or normalized values per RNA type for each
sample.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$plot_dist_per_sample(
  intra_norm = TRUE,
  inter_norm = TRUE,
  log2_expr = TRUE,
  geoms = c("boxplot"),
  mean_fun = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{intra_norm}}{A boolean indicating whether to apply intra-sample
normalization.}

\item{\code{inter_norm}}{A boolean indicating whether to apply inter-sample
normalization.}

\item{\code{log2_expr}}{A boolean indicating whether to use the log2(x+2)
transformation for expression data.}

\item{\code{geoms}}{Character vector, types of plot to draw, can be a
combination of:
\itemize{
\item "boxplot": draw a box plot (fast)
\item "violin": draw a violin plot (slow)
\item "histo": draw an hiostogram (slow)
}}

\item{\code{mean_fun}}{(Optional) Function to plot the mean per sample.
Can be one of the following:
\itemize{
\item "median"
\item "geometric"
\item "nz.geometric" geometric without zero
\item "mod.geometric" modified geometric with epsilon = 1e-05
(see https://arxiv.org/abs/1806.06403)
\item "arithmetic"
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
ggplot2 graph
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-plot_complex"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-plot_complex}{}}}
\subsection{Method \code{plot_complex()}}{
Function to draw complex plots
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$plot_complex(
  plot_type,
  in_batch = NULL,
  in_group = NULL,
  intra_norm = TRUE,
  inter_norm = TRUE,
  tr_fn = (function(x) log2(x + 2)),
  plot_scale = "group",
  ggplot_mod = NULL,
  color_palettes = c("Set1", "Set2", "Set3", "Pastel1", "Pastel2", "Paired", "Dark2",
    "Accent"),
  prcomp_args = list(),
  prcomp_autoplot_args = list(),
  dist_method = "euclidean",
  hclust_method = "ward.D2",
  dim_reduce = NULL,
  clust_bar_var = c(),
  height_main = 10,
  width_main = 4,
  include_ctrl_at_group_scale = FALSE,
  tags = NULL,
  tag_type = NULL,
  df_design_filter = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{plot_type}}{plot type
\itemize{
\item "prcomp" PCA analysis
\item "corr" correlation analysis
\item "hclust"
}}

\item{\code{in_batch}}{(optional) A character vector specifying the batch(es) to
include.}

\item{\code{in_group}}{(optional) A character vector specifying the group(s) to
include.}

\item{\code{intra_norm}}{A boolean indicating whether to apply intra-sample
normalization.}

\item{\code{inter_norm}}{A boolean indicating whether to apply inter-sample
normalization.}

\item{\code{tr_fn}}{data transformation function}

\item{\code{plot_scale}}{At which scale are the samples correlated. There are 3
possible option:
\itemize{
\item "design": all samples are compared together
\item "batch": all samples are compared together within batch
\item "group": all samples are compared together within group including ctrl
Note that with inter_scale=TRUE there might be cases where it is
not compatible with the scale inf inter norm.
(see compute_and_set_inter_norm)
}}

\item{\code{ggplot_mod}}{ggplot modifier that will be added to the graph that
are later arranged.}

\item{\code{color_palettes}}{name of the palette of color to use for plot in the
order of variable added.}

\item{\code{prcomp_args}}{args to be used with prcomp. It is used for the
the following value of plot_type:
\itemize{
\item prcomp
\item hclust when dim_reduce is not null
}}

\item{\code{prcomp_autoplot_args}}{list of argument that are used with autoplot
to plot the prcomp object (see ggfortify autoplot.pca_common). Note that
the design is given as data therefore the variable defined in the deisgn
can be used.}

\item{\code{dist_method}}{distand method, see dist function}

\item{\code{hclust_method}}{hierarchical clustering method (see hclust function)}

\item{\code{dim_reduce}}{reduction before clustering (not yet implemented)}

\item{\code{clust_bar_var}}{list of variable to include as legend as a color bar}

\item{\code{height_main}}{height value for main graph when combined vertically
with others. Others heights will be set to 1. Note that there can be more
than 1 others graphs. Used in the following plot_type:
\itemize{
\item hclust
}}

\item{\code{width_main}}{width value for main graph when combined horizontically
with others. Others widths will be set to 1. Note that there can be more
than 1 others graphs.
\itemize{
\item hclust
}}

\item{\code{include_ctrl_at_group_scale}}{whether to include the controls at
group scale}

\item{\code{tags}}{vector of tag ids to use for the plot}

\item{\code{tag_type}}{name of the tag type to use:
\itemize{
\item uniprot
\item symbol
\item type
\item tax_id (taxonomy)
\item tax_name (taxonomy)
if null, then the default id will be used (typed gene id at gene level
and transcript id at transcript level)
}}

\item{\code{df_design_filter}}{data frame to filter samples based on their name
and eventually their batch and/or group depending on the plot_scale.
\itemize{
\item if plot_scale = "design", expected column is "sample_name"
\item if plot_scale = "batch", expected columns are "sample_name" & "batch"
\item if plot_scale = "group", expected columns are "sample_name" & "batch" &
"code"
Note that unexpected columns will be ignored.
Default is null meaning that there is no filtering.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
ggplot2 graph
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-plot_prcomp"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-plot_prcomp}{}}}
\subsection{Method \code{plot_prcomp()}}{
plot principal components
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$plot_prcomp(
  in_batch = NULL,
  in_group = NULL,
  intra_norm = TRUE,
  inter_norm = TRUE,
  tr_fn = (function(x) log2(x + 2)),
  plot_scale = "group",
  ggplot_mod = NULL,
  prcomp_args = list(),
  prcomp_autoplot_args = list(),
  include_ctrl_at_group_scale = FALSE,
  tags = NULL,
  tag_type = NULL,
  df_design_filter = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{in_batch}}{(optional) A character vector specifying the batch(es) to
include.}

\item{\code{in_group}}{(optional) A character vector specifying the group(s) to
include.}

\item{\code{intra_norm}}{A boolean indicating whether to apply intra-sample
normalization.}

\item{\code{inter_norm}}{A boolean indicating whether to apply inter-sample
normalization.}

\item{\code{tr_fn}}{data transformation function}

\item{\code{plot_scale}}{At which scale are the samples correlated. There are 3
possible option:
\itemize{
\item "design": all samples are compared together
\item "batch": all samples are compared together within batch
\item "group": all samples are compared together within group including ctrl
Note that with inter_scale=TRUE there might be cases where it is
not compatible with the scale inf inter norm.
(see compute_and_set_inter_norm)
}}

\item{\code{ggplot_mod}}{ggplot modifier that will be added to the graph that
are later arranged.}

\item{\code{prcomp_args}}{args to be used with prcomp. It is used for the
the following value of plot_type:
\itemize{
\item prcomp
\item hclust when dim_reduce is not null
}}

\item{\code{prcomp_autoplot_args}}{list of argument that are used with autoplot
to plot the prcomp object (see ggfortify autoplot.pca_common). Note that
the design is given as data therefore the variable defined in the deisgn
can be used.}

\item{\code{include_ctrl_at_group_scale}}{whether to include the controls at
group scale}

\item{\code{tags}}{vector of tag ids to use for the plot}

\item{\code{tag_type}}{name of the tag type to use:
\itemize{
\item uniprot
\item symbol
\item type
\item tax_id (taxonomy)
\item tax_name (taxonomy)
if null, then the default id will be used (typed gene id at gene level
and transcript id at transcript level)
}}

\item{\code{df_design_filter}}{data frame to filter samples based on their name
and eventually their batch and/or group depending on the plot_scale.
\itemize{
\item if plot_scale = "design", expected column is "sample_name"
\item if plot_scale = "batch", expected columns are "sample_name" & "batch"
\item if plot_scale = "group", expected columns are "sample_name" & "batch" &
"code"
Note that unexpected columns will be ignored.
Default is null meaning that there is no filtering.
}}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-plot_corr"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-plot_corr}{}}}
\subsection{Method \code{plot_corr()}}{
plot correlations
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$plot_corr(
  in_batch = NULL,
  in_group = NULL,
  intra_norm = TRUE,
  inter_norm = TRUE,
  tr_fn = (function(x) log2(x + 2)),
  plot_scale = "group",
  ggplot_mod = NULL,
  include_ctrl_at_group_scale = FALSE,
  tags = NULL,
  tag_type = NULL,
  df_design_filter = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{in_batch}}{(optional) A character vector specifying the batch(es) to
include.}

\item{\code{in_group}}{(optional) A character vector specifying the group(s) to
include.}

\item{\code{intra_norm}}{A boolean indicating whether to apply intra-sample
normalization.}

\item{\code{inter_norm}}{A boolean indicating whether to apply inter-sample
normalization.}

\item{\code{tr_fn}}{data transformation function}

\item{\code{plot_scale}}{At which scale are the samples correlated. There are 3
possible option:
\itemize{
\item "design": all samples are compared together
\item "batch": all samples are compared together within batch
\item "group": all samples are compared together within group including ctrl
Note that with inter_scale=TRUE there might be cases where it is
not compatible with the scale inf inter norm.
(see compute_and_set_inter_norm)
}}

\item{\code{ggplot_mod}}{ggplot modifier that will be added to the graph that
are later arranged.}

\item{\code{include_ctrl_at_group_scale}}{whether to include the controls at
group scale}

\item{\code{tags}}{vector of tag ids to use for the plot}

\item{\code{tag_type}}{name of the tag type to use:
\itemize{
\item uniprot
\item symbol
\item type
\item tax_id (taxonomy)
\item tax_name (taxonomy)
if null, then the default id will be used (typed gene id at gene level
and transcript id at transcript level)
}}

\item{\code{df_design_filter}}{data frame to filter samples based on their name
and eventually their batch and/or group depending on the plot_scale.
\itemize{
\item if plot_scale = "design", expected column is "sample_name"
\item if plot_scale = "batch", expected columns are "sample_name" & "batch"
\item if plot_scale = "group", expected columns are "sample_name" & "batch" &
"code"
Note that unexpected columns will be ignored.
Default is null meaning that there is no filtering.
}}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-extract_pairwise_data_with_design"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-extract_pairwise_data_with_design}{}}}
\subsection{Method \code{extract_pairwise_data_with_design()}}{
Get formatted data for a group with its matching control within a batch
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$extract_pairwise_data_with_design(
  in_batch,
  in_group,
  include_ctrl = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{in_batch}}{(optional) A character vector specifying the batch(es) to
include.}

\item{\code{in_group}}{(optional) A character vector specifying the group(s) to
include.}

\item{\code{include_ctrl}}{A boolean indicating whether to include the control
group. This argument is only valid when specifying only one argument for
'in_group' and 'in_batch'.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
list with selected attributes:
\itemize{
\item "raw" : matrix of raw values for test and control samples specified as
column names
\item "len" : matrix of tag lenght values for test and control samples
specified as column names
\item "intra_norm_fact" : matrix intra normalization factors
\item "inter_norm_fact" : vector of inter normalization factors
\item "norm_fact" : vector of inter normalization factors
\item "test_samples" : vector with test sample names
\item "ctrl_samples" : vector with control sample names
\item "design_table" : design table only for those samples
\item "ctrl_group" : the control group
}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-clone"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
