% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/class_ExprData.r
\name{ExprData}
\alias{ExprData}
\title{An R6 class representing an RNA-Seq expression dataset.}
\description{
This class represents a RNA sequencing dataset containing the
following information:
\itemize{
\item expression values (raw count) of expressed tags (genes or transcripts) for
all samples.
\item effective lengths of expressed tags (genes or transcripts) for all samples.
\item normalization factors for expressed tags (genes or transcripts) for all
samples.
\item design and annotation information; see \link{PairwiseDesignWith}
for details.
}

By convention, the dataset is represented as a matrix:
\itemize{
\item A column represents the expression values for one sample.
\item A row represents the expression values for one expression tag.
Column names are the sample names, and row names are the expression tag
names.
}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-ExprData-show_etags_summary}{\code{ExprData$show_etags_summary()}}
\item \href{#method-ExprData-plot_etags_summary}{\code{ExprData$plot_etags_summary()}}
\item \href{#method-ExprData-filter_and_set_selected_ids}{\code{ExprData$filter_and_set_selected_ids()}}
\item \href{#method-ExprData-compute_and_set_inter_norm_fact}{\code{ExprData$compute_and_set_inter_norm_fact()}}
\item \href{#method-ExprData-compute_and_set_intra_norm_fact}{\code{ExprData$compute_and_set_intra_norm_fact()}}
\item \href{#method-ExprData-reset}{\code{ExprData$reset()}}
\item \href{#method-ExprData-get_raw}{\code{ExprData$get_raw()}}
\item \href{#method-ExprData-filter_and_get_raw}{\code{ExprData$filter_and_get_raw()}}
\item \href{#method-ExprData-get_len}{\code{ExprData$get_len()}}
\item \href{#method-ExprData-filter_and_get_len}{\code{ExprData$filter_and_get_len()}}
\item \href{#method-ExprData-compute_norm_fact}{\code{ExprData$compute_norm_fact()}}
\item \href{#method-ExprData-get_intra_norm_fact_method}{\code{ExprData$get_intra_norm_fact_method()}}
\item \href{#method-ExprData-get_inter_norm_fact_opts}{\code{ExprData$get_inter_norm_fact_opts()}}
\item \href{#method-ExprData-compute_norm}{\code{ExprData$compute_norm()}}
\item \href{#method-ExprData-is_with_fixed_length}{\code{ExprData$is_with_fixed_length()}}
\item \href{#method-ExprData-get_intra_norm_fact}{\code{ExprData$get_intra_norm_fact()}}
\item \href{#method-ExprData-get_inter_norm_fact}{\code{ExprData$get_inter_norm_fact()}}
\item \href{#method-ExprData-get_main_etag}{\code{ExprData$get_main_etag()}}
\item \href{#method-ExprData-is_at_gene_level}{\code{ExprData$is_at_gene_level()}}
\item \href{#method-ExprData-get_design}{\code{ExprData$get_design()}}
\item \href{#method-ExprData-get_annotation}{\code{ExprData$get_annotation()}}
\item \href{#method-ExprData-plot_dist_per_sample}{\code{ExprData$plot_dist_per_sample()}}
\item \href{#method-ExprData-extract_pairwise_data_with_design}{\code{ExprData$extract_pairwise_data_with_design()}}
\item \href{#method-ExprData-clean_id_versions}{\code{ExprData$clean_id_versions()}}
\item \href{#method-ExprData-plot_prcomp}{\code{ExprData$plot_prcomp()}}
\item \href{#method-ExprData-plot_corr}{\code{ExprData$plot_corr()}}
\item \href{#method-ExprData-plot_hclust}{\code{ExprData$plot_hclust()}}
\item \href{#method-ExprData-clone}{\code{ExprData$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-show_etags_summary"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-show_etags_summary}{}}}
\subsection{Method \code{show_etags_summary()}}{
This function computes a summary per tax_id, tax_name and rna type for
selected expressed tags, and returns a list of tables per feature.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$show_etags_summary(
  in_batch = NULL,
  tr_fn = NULL,
  sum_fn = sum,
  intra_norm = FALSE,
  inter_norm = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{in_batch}}{(optional) A character vector specifying the batch(es) to
include.}

\item{\code{tr_fn}}{A function to transform the expression values before
summarizing. Default is identity function (no transformation).}

\item{\code{sum_fn}}{A function to aggregate the transformed values. Default
is "sum", but can be "sum_fn = function(x) sum(as.integer(x > 0))"
to count non zero genes for example.}

\item{\code{intra_norm}}{A boolean indicating whether to apply intra-sample
normalization. Only used when type="norm".}

\item{\code{inter_norm}}{A boolean indicating whether to apply inter-sample
normalization. Only used when type="norm".}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of tables per feature
Plot results from show_etags_summary.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-plot_etags_summary"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-plot_etags_summary}{}}}
\subsection{Method \code{plot_etags_summary()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$plot_etags_summary(
  in_batch = NULL,
  tr_fn = NULL,
  sum_fn = sum,
  intra_norm = FALSE,
  inter_norm = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{in_batch}}{(optional) A character vector specifying the batch(es) to
include.}

\item{\code{tr_fn}}{A function to transform the expression values before
summarizing. Default is identity function (no transformation).}

\item{\code{sum_fn}}{A function to aggregate the transformed values. Default
is "sum", but can be "sum_fn = function(x) sum(as.integer(x > 0))"
to count non zero genes for example.}

\item{\code{intra_norm}}{A boolean indicating whether to apply intra-sample
normalization. Only used when type="norm".}

\item{\code{inter_norm}}{A boolean indicating whether to apply inter-sample
normalization. Only used when type="norm".}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of tables per feature
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-filter_and_set_selected_ids"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-filter_and_set_selected_ids}{}}}
\subsection{Method \code{filter_and_set_selected_ids()}}{
Select expressed tags based on filtering on taxon or rna type.
The results will be an intersect with the previous selection.
You can reset the object if it's not desired.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$filter_and_set_selected_ids(
  values,
  filtered_var = "type",
  filter_type = "keep"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{values}}{A list of values used for filtering.
e.g c("mRNA", "transcript")}

\item{\code{filtered_var}}{The variable being filtered. Possible values are
\itemize{
\item "tax_id" for filtering based on taxon id
\item "tax_name" for filtering based on taxon name
\item "type" for filtering based on rna type (default)
}}

\item{\code{filter_type}}{The filtering method. Possible values are:
\itemize{
\item "keep" to keep only an expression tag if its value for the variable
designated with \code{filtered_var} is in \code{values}
\item "excl" to keep only an expression tag if its value for the variable
designated with \code{filtered_var} is not in \code{values}.
Compute and set inter normalization factors
}}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-compute_and_set_inter_norm_fact"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-compute_and_set_inter_norm_fact}{}}}
\subsection{Method \code{compute_and_set_inter_norm_fact()}}{
Compute and set inter normalization factors


This function computes scaling factors using a ratio-based
method to correct for systematic technical biases between samples, such
as differences in sequencing depth or library composition. By default, it
performs Median Ratio Normalization (MRN), as \code{norm_mean} is \code{"median"}
and M-value trimming is disabled (\code{m_trim_prop = 0}). It can be
configured to perform TMM-style normalization by setting \code{m_trim_prop}
and norm_mean="geometric"\code{or}norm_mean="mod.geometric"`. Note that the
weigthed mean for TMM is not available yet.

The normalization process is as follows:
\enumerate{
\item \strong{Reference Selection}: A reference expression profile is created
from samples chosen via \code{ref_type} and \code{ref_samples}. Gene expression
values are averaged using the \code{ref_mean} method.
\item \strong{Target Processing}: For each target sample or group (\code{norm_by}), a
target expression profile is created using \code{tgt_mean}.
\item \strong{M and A Vector Calculation}:
\itemize{
\item The \strong{A-vector} (average expression) is used to filter out
low-expression genes, which can be noisy.
\item The \strong{M-vector} (expression ratio: target/reference) is used to
derive the normalization factor from its central tendency.
}
\item \strong{Trimming Process}: A sequential trimming process refines the set
of genes used for normalization:
\itemize{
\item \strong{A-vector trimming}: Genes with average expression below
\code{a_trim_value} are removed.
\item \strong{M-vector trimming}: A proportion (\code{m_trim_prop}) of genes with
the most extreme expression ratios are removed. This is disabled by
default (\code{m_trim_prop = 0}).
\item \strong{Extreme ratio trimming}: If \code{trim_extreme} is \code{TRUE}, genes with
infinite or zero ratios are removed. This is advised when \code{norm_mean}
is not \code{"median"} or when \code{m_trim_prop} is too small to remove these
values.
}
\item \strong{Factor Calculation}: The final normalization factor is computed by
applying \code{norm_mean} to the ratio (M-vector) of the remaining genes.
\item \strong{Normalization Scope (\code{norm_scale})}: This parameter determines the
scope and reference for normalization.
\itemize{
\item \strong{\code{design}}: Normalization is performed across all samples at once
This is the generally recommended approach as it makes all samples
comparable across the entire experiment.
\item \strong{\code{batch}} or \strong{\code{group}}: Normalization is performed
independently within each context. This can mitigate biases if a
particular batch or group is compositionally very different. However,
it renders data comparable only \emph{within} that same context
(e.g., within a batch), not across the entire design.
}
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$compute_and_set_inter_norm_fact(
  norm_scale = "design",
  norm_by = "sample",
  ref_type = "all",
  ref_samples = NULL,
  ref_mean = "arithmetic",
  norm_mean = "median",
  tgt_mean = "arithmetic",
  a_mean = "arithmetic",
  a_trim_value = 1,
  m_trim_prop = 0,
  trim_extreme = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{norm_scale}}{Scale to apply the normalization:
\itemize{
\item "design" for all samples in one go
\item "batch" for applying norm_factors per batch
\item "group" for applying norm factors per batch per group.
The scale will have an impact on the reference selection if ref type is
"ctrl" or "all". In consequences the same sample can be associated with
different scaling factor if it appears in different batch/group.
Therefore data normalized at the "batch" or "group" level can not be
analyzed at the design level. (and group scale not at the batch level
either). Indeed at group/batch levels the inter_norm can only be applied
at group/batch level.
}}

\item{\code{norm_by}}{level by which M and A vector are computed followed by.
the scaling factor for normalization.}

\item{\code{ref_type}}{Type of reference samples to use for normalization.
\itemize{
\item "all" for using all samples as reference
\item "ctrl" for using only control samples as reference
\item "specified" for using specific samples \code{ref_samples} as reference
}}

\item{\code{ref_samples}}{Samples to use as reference for normalization.}

\item{\code{ref_mean}}{Method for averaging gene expression across reference
samples. It is recommended to use the same method for \code{ref_mean},
\code{tgt_mean}, and \code{a_mean}.
\itemize{
\item \strong{\code{"arithmetic"}}: Recommended when using library size-scaled
intra-normalization (e.g., "tpm", "fpkm", "fpm"). This preserves the
sum of proportions.
\item \strong{\code{"geometric"}}: Recommended when intra-normalization does not
account for library size (e.g., "none", "fpk"). The library size effect
is then absorbed into the inter-sample normalization factor. This
approach, with "none" intra-normalization, mirrors the default
behavior in DESeq2. Note that this can be problematic if normalization
is performed per group (\code{norm_by = "group"}).
\item Other options: \code{"median"}, \code{"nz.geometric"}, \code{"mod.geometric"}.
}}

\item{\code{norm_mean}}{Method for the mean of ratios between the target and the
reference. See \code{ref_mean} for possible values.}

\item{\code{tgt_mean}}{Method for averaging gene expression across target
samples. See \code{ref_mean} for recommended usage and available options.}

\item{\code{a_mean}}{Method for averaging gene expression between target and
reference samples to calculate the A-vector. See \code{ref_mean} for
recommended usage and available options.}

\item{\code{a_trim_value}}{Value for trimming the A vector.}

\item{\code{m_trim_prop}}{Proportion of values to trim from the M vector.}

\item{\code{trim_extreme}}{Whether to trim extreme values from the M vector,
before calculating the mean. If the mean function \code{norm_mean} is not
"median", extreme values will causes issues with the calculation of the
mean.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-compute_and_set_intra_norm_fact"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-compute_and_set_intra_norm_fact}{}}}
\subsection{Method \code{compute_and_set_intra_norm_fact()}}{
Set intra normalization factors.
This function replaces any NaN values in the intra normalization factors
with 1. NaN values may occur when the denominator in the calculations is
0. Replacing NaN values with 1 ensures that the normalization factors do
not have missing or undefined values, which can cause issues in further
analyses.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$compute_and_set_intra_norm_fact(method)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{method}}{Normalization method:
\itemize{
\item "none" for no normalization
\item "fpm" for Fragment per million mapped
\item "fpk" for Fragment per kilobase of transcript
\item "tpm" for Transcript per million
\item "fpkm" for Fragment per kilobase of transcript per million mapped
}}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-reset"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-reset}{}}}
\subsection{Method \code{reset()}}{
Reset object, this affects:
\itemize{
\item expression tags selection (as initially)
\item samples selection (as initially)
\item normalization (No norm)
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$reset()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
interger matrix with raw counts for expressed tags
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-get_raw"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-get_raw}{}}}
\subsection{Method \code{get_raw()}}{
Get raw count matrix
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$get_raw()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
interger matrix with raw counts for expressed tags
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-filter_and_get_raw"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-filter_and_get_raw}{}}}
\subsection{Method \code{filter_and_get_raw()}}{
Filter and get raw count matrix
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$filter_and_get_raw(
  in_batch = NULL,
  in_group = NULL,
  include_ctrl = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{in_batch}}{(optional) A character vector specifying the batch(es) to
include.}

\item{\code{in_group}}{(optional) A character vector specifying the group(s) to
include.}

\item{\code{include_ctrl}}{when in_group is specified, will include batch ctrl}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
interger matrix with raw counts for expressed tags
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-get_len"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-get_len}{}}}
\subsection{Method \code{get_len()}}{
Get effective length matrix
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$get_len()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
numeric matrix with effective length  for expressed tags
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-filter_and_get_len"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-filter_and_get_len}{}}}
\subsection{Method \code{filter_and_get_len()}}{
filter and get effective length matrix
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$filter_and_get_len(in_batch = NULL, in_group = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{in_batch}}{(optional) A character vector specifying the batch(es) to
include.}

\item{\code{in_group}}{(optional) A character vector specifying the group(s) to
include.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
numeric matrix with effective length  for expressed tags
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-compute_norm_fact"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-compute_norm_fact}{}}}
\subsection{Method \code{compute_norm_fact()}}{
Get normalization factors matrix
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$compute_norm_fact(
  in_batch = NULL,
  in_group = NULL,
  inter_norm = FALSE,
  intra_norm = TRUE,
  include_ctrl = FALSE,
  rescale_inter_norm = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{in_batch}}{(optional) A character vector specifying the batch(es) to
include.}

\item{\code{in_group}}{(optional) A character vector specifying the group(s) to
include.}

\item{\code{inter_norm}}{A boolean indicating whether to apply inter-sample
normalization.}

\item{\code{intra_norm}}{A boolean indicating whether to apply intra-sample
normalization.}

\item{\code{include_ctrl}}{if TRUE and if \code{in_batch} and \code{in_group} are
specified, control samples from the specified batch will be included.}

\item{\code{rescale_inter_norm}}{Rescale inter-sample normalization factors so
that their geometric mean is 1. Default is TRUE.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Numeric matrix with normalization factors for expressed tags
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-get_intra_norm_fact_method"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-get_intra_norm_fact_method}{}}}
\subsection{Method \code{get_intra_norm_fact_method()}}{
Get intra normalization method
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$get_intra_norm_fact_method()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
method name
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-get_inter_norm_fact_opts"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-get_inter_norm_fact_opts}{}}}
\subsection{Method \code{get_inter_norm_fact_opts()}}{
Get inter normalization methods
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$get_inter_norm_fact_opts()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
lists with all normalizations options
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-compute_norm"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-compute_norm}{}}}
\subsection{Method \code{compute_norm()}}{
Compute the normalized expression data from raw and norm matrices.

\strong{IMPORTANT}: Default is no normalization. Please use the function below
beforehand.
\itemize{
\item "compute_and_set_intra_norm_fact"
\item "compute_and_set_inter_norm_fact"
Note that intra normalization is always applied, however inter norm is
optional. Depending on the \code{norm_scale} used for inter normalization,
the \code{in_batch} argument might be mandatory.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$compute_norm(
  in_batch = NULL,
  in_group = NULL,
  intra_norm = TRUE,
  inter_norm = FALSE,
  include_ctrl = FALSE,
  rescale_inter_norm = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{in_batch}}{(optional) A character vector specifying the batch(es) to
include.}

\item{\code{in_group}}{(optional) A character vector specifying the group(s) to
include.}

\item{\code{intra_norm}}{A boolean indicating whether to apply intra-sample
normalization.}

\item{\code{inter_norm}}{A boolean indicating whether to apply inter-sample
normalization.}

\item{\code{include_ctrl}}{include control samples in the normalization}

\item{\code{rescale_inter_norm}}{Rescale inter-sample normalization factors so
that their geometric mean is 1. Default is TRUE.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
numeric matrix with norm counts for expressed tags
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-is_with_fixed_length"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-is_with_fixed_length}{}}}
\subsection{Method \code{is_with_fixed_length()}}{
Are the expression tags lengths fixed ?
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$is_with_fixed_length()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
numeric matrix with raw counts for expressed tags
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-get_intra_norm_fact"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-get_intra_norm_fact}{}}}
\subsection{Method \code{get_intra_norm_fact()}}{
Get the intra normalization factor
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$get_intra_norm_fact(in_batch = NULL, in_group = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{in_batch}}{(optional) A character vector specifying the batch(es) to
include.}

\item{\code{in_group}}{(optional) A character vector specifying the group(s) to
include.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
numeric matrix with intra normalization factor
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-get_inter_norm_fact"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-get_inter_norm_fact}{}}}
\subsection{Method \code{get_inter_norm_fact()}}{
Get the inter normalization factor
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$get_inter_norm_fact(in_batch = NULL, in_group = NULL, rescale = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{in_batch}}{(optional) A character vector specifying the batch(es) to
include.}

\item{\code{in_group}}{(optional) A character vector specifying the group(s) to
include.}

\item{\code{rescale}}{Rescale the factors so that their geometric mean is 1.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-get_main_etag"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-get_main_etag}{}}}
\subsection{Method \code{get_main_etag()}}{
Get the main expression tag id. The tag id corresponds to the unique id
linked with a expression point. It can be tx_id (for transcript id) or
"tgid" for "typed gene id". Why typed gene ID ? because some genes have
transcripts from different types. As it would not be biologically
relevant to aggregate different typse during the sum, a new id is create
that is gene and type specific.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$get_main_etag()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
chararacter representing the main espression tag id
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-is_at_gene_level"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-is_at_gene_level}{}}}
\subsection{Method \code{is_at_gene_level()}}{
Whether the expression data is at gene level or not.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$is_at_gene_level()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
T or F
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-get_design"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-get_design}{}}}
\subsection{Method \code{get_design()}}{
Extract the PairwiseDesign instance that were used to
build the expression data object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$get_design()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
\code{PairwiseDesign} object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-get_annotation"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-get_annotation}{}}}
\subsection{Method \code{get_annotation()}}{
Extract the Annotation instance that were used to
build the expression data object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$get_annotation()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
\code{Annotation} object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-plot_dist_per_sample"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-plot_dist_per_sample}{}}}
\subsection{Method \code{plot_dist_per_sample()}}{
Plot the distribution of count or normalized values per RNA type for each
sample.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$plot_dist_per_sample(
  intra_norm = TRUE,
  inter_norm = TRUE,
  geoms = c("histo", "boxplot"),
  tr_fn = (function(x) log2(x + 2) - 1),
  mean_fun = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{intra_norm}}{A boolean indicating whether to apply intra-sample
normalization.}

\item{\code{inter_norm}}{A boolean indicating whether to apply inter-sample
normalization.}

\item{\code{geoms}}{Character vector, types of plot to draw, can be a
combination of:
\itemize{
\item "boxplot": draw a box plot (fast)
\item "violin": draw a violin plot (slow)
\item "histo": draw an hiostogram (slow)
}}

\item{\code{tr_fn}}{function to transform expression values before plot.}

\item{\code{mean_fun}}{(Optional) Function to plot the mean per sample.
Can be one of the following:
\itemize{
\item "median"
\item "geometric"
\item "nz.geometric" geometric without zero
\item "mod.geometric" modified geometric with epsilon = 1e-05
(see https://arxiv.org/abs/1806.06403)
\item "arithmetic"
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
ggplot2 graph
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-extract_pairwise_data_with_design"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-extract_pairwise_data_with_design}{}}}
\subsection{Method \code{extract_pairwise_data_with_design()}}{
Get formatted data for a group with its matching control within a batch
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$extract_pairwise_data_with_design(
  in_batch,
  in_group,
  rescale_inter_norm = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{in_batch}}{(optional) A character vector specifying the batch(es) to
include.}

\item{\code{in_group}}{(optional) A character vector specifying the group(s) to
include.}

\item{\code{rescale_inter_norm}}{Rescale inter-sample normalization factors so
that their geometric mean is 1. Default is TRUE.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
list with selected attributes:
\itemize{
\item "raw" : matrix of raw values for test and control samples specified as
column names
\item "len" : matrix of tag lenght values for test and control samples
specified as column names
\item "intra_norm_fact" : matrix intra normalization factors
\item "inter_norm_fact" : vector of inter normalization factors
\item "norm_fact" : vector of inter normalization factors
\item "test_samples" : vector with test sample names
\item "ctrl_samples" : vector with control sample names
\item "design_table" : design table only for those samples
\item "ctrl_group" : the control group
}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-clean_id_versions"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-clean_id_versions}{}}}
\subsection{Method \code{clean_id_versions()}}{
Clean version suffixes from expression tag IDs.

This method applies the \code{remove_id_version_suffix} utility to the
row names of internal data matrices (\code{raw}, \code{len}, \code{intra_norm_fact})
and to \code{selected_ids}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$clean_id_versions(suffix_pattern = "\\\\.\\\\d+$")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{suffix_pattern}}{(character) The regex pattern for the version
suffix. Default is \code{"-\\\\d+$"}. If \code{NULL}, \code{FALSE}, or an empty string,
no cleaning is performed.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-plot_prcomp"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-plot_prcomp}{}}}
\subsection{Method \code{plot_prcomp()}}{
Function to draw PCA plots
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$plot_prcomp(
  in_batch = NULL,
  in_group = NULL,
  intra_norm = TRUE,
  inter_norm = TRUE,
  tr_fn = (function(x) log2(x + 2)),
  plot_scale = "group",
  ggplot_mod = NULL,
  color_palette = "Paired",
  prcomp_args = list(),
  include_ctrl_at_group_scale = FALSE,
  tags = NULL,
  tag_type = NULL,
  pca_plot_dims = c(1L, 2L),
  mshape = setNames("b_label", "Batch"),
  mcolor = setNames("g_label", "Group"),
  point_size = 5
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{in_batch}}{(optional) A character vector specifying the batch(es) to
include.}

\item{\code{in_group}}{(optional) A character vector specifying the group(s) to
include.}

\item{\code{intra_norm}}{A boolean indicating whether to apply intra-sample
normalization.}

\item{\code{inter_norm}}{A boolean indicating whether to apply inter-sample
normalization.}

\item{\code{tr_fn}}{data transformation function}

\item{\code{plot_scale}}{At which scale are the samples correlated.}

\item{\code{ggplot_mod}}{ggplot modifier that will be added to the graph.}

\item{\code{color_palette}}{name of the palette of color to use}

\item{\code{prcomp_args}}{args to be used with prcomp.}

\item{\code{include_ctrl_at_group_scale}}{whether to include the controls at
group scale}

\item{\code{tags}}{vector of tag ids to use for the plot}

\item{\code{tag_type}}{name of the tag type to use}

\item{\code{pca_plot_dims}}{integer id the the principal component to plot}

\item{\code{mshape}}{Which variable to use for shape mapping}

\item{\code{mcolor}}{Which variable to use for color mapping}

\item{\code{point_size}}{point size for geom plot}

\item{\code{prcomp_autoplot_args}}{list of argument that are used with autoplot.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
ggplot2 graph
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-plot_corr"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-plot_corr}{}}}
\subsection{Method \code{plot_corr()}}{
Function to draw correlation plots
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$plot_corr(
  in_batch = NULL,
  in_group = NULL,
  intra_norm = TRUE,
  inter_norm = TRUE,
  tr_fn = (function(x) log2(x + 2)),
  plot_scale = "group",
  ggplot_mod = NULL,
  include_ctrl_at_group_scale = FALSE,
  tags = NULL,
  tag_type = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{in_batch}}{(optional) A character vector specifying the batch(es) to
include.}

\item{\code{in_group}}{(optional) A character vector specifying the group(s) to
include.}

\item{\code{intra_norm}}{A boolean indicating whether to apply intra-sample
normalization.}

\item{\code{inter_norm}}{A boolean indicating whether to apply inter-sample
normalization.}

\item{\code{tr_fn}}{data transformation function}

\item{\code{plot_scale}}{At which scale are the samples correlated.}

\item{\code{ggplot_mod}}{ggplot modifier that will be added to the graph.}

\item{\code{include_ctrl_at_group_scale}}{whether to include the controls at
group scale}

\item{\code{tags}}{vector of tag ids to use for the plot}

\item{\code{tag_type}}{name of the tag type to use}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
ggplot2 graph
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-plot_hclust"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-plot_hclust}{}}}
\subsection{Method \code{plot_hclust()}}{
Function to draw hierarchical clustering plots
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$plot_hclust(
  in_batch = NULL,
  in_group = NULL,
  intra_norm = TRUE,
  inter_norm = TRUE,
  tr_fn = (function(x) log2(x + 2)),
  plot_scale = "group",
  ggplot_mod = NULL,
  color_palette = "BrBG",
  dist_method = "euclidean",
  hclust_method = "ward.D2",
  dim_reduce = NULL,
  clust_bar_var = c(),
  height_main = 10,
  width_main = 4,
  prcomp_args = list(),
  include_ctrl_at_group_scale = FALSE,
  tags = NULL,
  tag_type = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{in_batch}}{(optional) A character vector specifying the batch(es) to
include.}

\item{\code{in_group}}{(optional) A character vector specifying the group(s) to
include.}

\item{\code{intra_norm}}{A boolean indicating whether to apply intra-sample
normalization.}

\item{\code{inter_norm}}{A boolean indicating whether to apply inter-sample
normalization.}

\item{\code{tr_fn}}{data transformation function}

\item{\code{plot_scale}}{At which scale are the samples correlated.}

\item{\code{ggplot_mod}}{ggplot modifier that will be added to the graph.}

\item{\code{color_palette}}{name of the palette of color to use}

\item{\code{dist_method}}{distance method}

\item{\code{hclust_method}}{hierarchical clustering method}

\item{\code{dim_reduce}}{reduction before clustering}

\item{\code{clust_bar_var}}{list of variable to include as legend as a color bar}

\item{\code{height_main}}{height value for main graph}

\item{\code{width_main}}{width value for main graph}

\item{\code{prcomp_args}}{args to be used with prcomp.}

\item{\code{include_ctrl_at_group_scale}}{whether to include the controls at
group scale}

\item{\code{tags}}{vector of tag ids to use for the plot}

\item{\code{tag_type}}{name of the tag type to use}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
ggplot2 graph
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ExprData-clone"></a>}}
\if{latex}{\out{\hypertarget{method-ExprData-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ExprData$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
